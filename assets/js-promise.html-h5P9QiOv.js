import{_ as s,c as a,a as e,o as t}from"./app-B88TDsre.js";const l={};function n(p,i){return t(),a("div",null,i[0]||(i[0]=[e(`<p>在 JavaScript 中，Promise 是处理异步编程的重要工具。要深入理解 Promise 的执行过程，我们需要从 JavaScript 引擎的执行机制入手，尤其是 事件循环（Event Loop）和 任务队列（Task Queue）的运作方式。</p><h2 id="一、任务队列的两大类型" tabindex="-1"><a class="header-anchor" href="#一、任务队列的两大类型"><span>一、任务队列的两大类型</span></a></h2><p>JavaScript 中的任务队列分为两种主要类型：</p><ul><li>宏任务队列（Macrotask Queue）：包含如 setTimeout、setInterval 和 DOM 事件处理等任务</li><li>微任务队列（Microtask Queue）：专门用于存放 Promise 回调、MutationObserver 等任务</li></ul><h2 id="二、事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#二、事件循环-event-loop"><span>二、事件循环（Event Loop）</span></a></h2><p>事件循环的工作原理是不断检查执行栈是否为空：</p><ul><li>如果执行栈为空，首先检查微任务队列，依次执行其中的所有微任务</li><li>清空微任务队列后，从宏任务队列中取出一个任务执行</li><li>重复以上步骤，形成循环</li></ul><h2 id="三、javascript-引擎执行过程" tabindex="-1"><a class="header-anchor" href="#三、javascript-引擎执行过程"><span>三、JavaScript 引擎执行过程</span></a></h2><p>执行过程主要包括以下步骤：</p><ol><li>执行同步代码（栈中的任务）</li><li>执行所有微任务</li><li>执行一个宏任务</li><li>重复步骤 2 和 3</li></ol><h2 id="四、示例解析" tabindex="-1"><a class="header-anchor" href="#四、示例解析"><span>四、示例解析</span></a></h2><p>让我们看一个简单的例子，来理解输出顺序：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;1&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 同步任务</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// setTimeout 提交了一个宏任务到宏任务队列</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 宏任务</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Promise 添加了一个微任务到微任务队列</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;3&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 微任务</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;4&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 同步任务</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行过程</p><ul><li>先执行同步任务，输出 1 和 4</li><li>因为 Promise 添加了微任务，所以同步代码执行后会执行微任务输出 3</li><li>最后再执行 setTimeout 提交的宏任务输出 2 最终输出顺序将是：1, 4, 3, 2</li></ul><h2 id="五、async-await-——-promise-的语法糖" tabindex="-1"><a class="header-anchor" href="#五、async-await-——-promise-的语法糖"><span>五、async/await —— Promise 的语法糖</span></a></h2><p>async/await 是 ES2017 引入的处理 Promise 的新语法，使异步代码看起来像同步代码，极大提高了可读性。</p><ul><li>async 函数返回一个 Promise</li><li>await 只能在 async 函数内使用，它会暂停函数执行，直到 Promise 解决（Fulfilled 或 Rejected） 通过 async/await，你可以轻松处理复杂的异步逻辑，写出更清晰的代码</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>掌握 Promise 的执行过程和事件循环的原理，是提高 JavaScript 编程能力的关键。理解微任务和宏任务的区别，有助于你更好地管理异步操作，优化代码性能。如果你觉得这篇文章对你有所帮助，别忘了点赞和分享，让更多人了解 Promise 的奥秘！🚀</p>`,20)]))}const h=s(l,[["render",n],["__file","js-promise.html.vue"]]),k=JSON.parse('{"path":"/code/fe/js-promise.html","title":"彻底解析 Promise 执行过程：从事件循环到 async/await 轻松掌握！","lang":"zh-CN","frontmatter":{"title":"彻底解析 Promise 执行过程：从事件循环到 async/await 轻松掌握！","shortTitle":"彻底解析 Promise 执行过程","icon":"p","date":"2024-09-23T15:49:32.000Z","category":["前端","js"],"tag":["js","promise"],"order":40,"description":"在 JavaScript 中，Promise 是处理异步编程的重要工具。要深入理解 Promise 的执行过程，我们需要从 JavaScript 引擎的执行机制入手，尤其是 事件循环（Event Loop）和 任务队列（Task Queue）的运作方式。 一、任务队列的两大类型 JavaScript 中的任务队列分为两种主要类型： 宏任务队列（Macr...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/js-promise.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"彻底解析 Promise 执行过程：从事件循环到 async/await 轻松掌握！"}],["meta",{"property":"og:description","content":"在 JavaScript 中，Promise 是处理异步编程的重要工具。要深入理解 Promise 的执行过程，我们需要从 JavaScript 引擎的执行机制入手，尤其是 事件循环（Event Loop）和 任务队列（Task Queue）的运作方式。 一、任务队列的两大类型 JavaScript 中的任务队列分为两种主要类型： 宏任务队列（Macr..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-05T02:09:58.000Z"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"promise"}],["meta",{"property":"article:published_time","content":"2024-09-23T15:49:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-05T02:09:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"彻底解析 Promise 执行过程：从事件循环到 async/await 轻松掌握！\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-23T15:49:32.000Z\\",\\"dateModified\\":\\"2024-11-05T02:09:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"一、任务队列的两大类型","slug":"一、任务队列的两大类型","link":"#一、任务队列的两大类型","children":[]},{"level":2,"title":"二、事件循环（Event Loop）","slug":"二、事件循环-event-loop","link":"#二、事件循环-event-loop","children":[]},{"level":2,"title":"三、JavaScript 引擎执行过程","slug":"三、javascript-引擎执行过程","link":"#三、javascript-引擎执行过程","children":[]},{"level":2,"title":"四、示例解析","slug":"四、示例解析","link":"#四、示例解析","children":[]},{"level":2,"title":"五、async/await —— Promise 的语法糖","slug":"五、async-await-——-promise-的语法糖","link":"#五、async-await-——-promise-的语法糖","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1730721795000,"updatedTime":1730772598000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":2}]},"readingTime":{"minutes":2.24,"words":672},"filePathRelative":"code/fe/js-promise.md","localizedDate":"2024年9月23日","excerpt":"<p>在 JavaScript 中，Promise 是处理异步编程的重要工具。要深入理解 Promise 的执行过程，我们需要从 JavaScript 引擎的执行机制入手，尤其是 事件循环（Event Loop）和 任务队列（Task Queue）的运作方式。</p>\\n<h2>一、任务队列的两大类型</h2>\\n<p>JavaScript 中的任务队列分为两种主要类型：</p>\\n<ul>\\n<li>宏任务队列（Macrotask Queue）：包含如 setTimeout、setInterval 和 DOM 事件处理等任务</li>\\n<li>微任务队列（Microtask Queue）：专门用于存放 Promise 回调、MutationObserver 等任务</li>\\n</ul>","autoDesc":true}');export{h as comp,k as data};
