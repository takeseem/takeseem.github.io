import{_ as i,c as t,a as l,o as a}from"./app-C4a0fRix.js";const s={};function n(r,e){return a(),t("div",null,e[0]||(e[0]=[l(`<h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://zh-hans.react.dev/learn/escape-hatches" target="_blank" rel="noopener noreferrer">React 官方文档</a></li><li><a href="https://www.takeseem.com/demo-react/demo/react-escape" target="_blank" rel="noopener noreferrer">demo</a></li></ul><h2 id="怎样-记住-信息-而不触发重新渲染" tabindex="-1"><a class="header-anchor" href="#怎样-记住-信息-而不触发重新渲染"><span>怎样“记住”信息，而不触发重新渲染？</span></a></h2><ul><li>可以使用 <code>ref</code>，它会记住信息，ref 的变更也不会触发新的渲染。</li><li>ref 和 state 的区别 <table><thead><tr><th>ref</th><th>state</th></tr></thead><tbody><tr><td><a href="https://zh-hans.react.dev/reference/react/useRef#reference" target="_blank" rel="noopener noreferrer">useRef</a></td><td><a href="https://zh-hans.react.dev/reference/react/useState#reference" target="_blank" rel="noopener noreferrer"><code>useState</code></a></td></tr><tr><td>修改时不触发渲染</td><td>修改时触发渲染</td></tr><tr><td>可变，可以在渲染过程之外修改 current 的值</td><td>“不可变”，你必须使用 state setter 函数修改 state，从而排队重新渲染</td></tr><tr><td>不应在渲染期间读取、写入 current</td><td>可以随时读取 state，但每次渲染都有自己不变的 state 快照</td></tr></tbody></table></li><li>何时使用 <a href="https://zh-hans.react.dev/reference/react/useRef#reference" target="_blank" rel="noopener noreferrer">useRef</a>？ <ul><li>当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener noreferrer">timeout ID</a></li><li>存储和操作 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element" target="_blank" rel="noopener noreferrer">DOM 元素</a></li><li>存储不需要被用来计算 JSX 的其他对象</li></ul></li><li>ref 的最佳实践 <ul><li><code>将 ref 视为脱围机制</code>：当使用外部系统或浏览器 API 时，如果应用程序逻辑和数据流很大一部分依赖于 ref，你可能需要重新考虑你的设计。</li><li><code>不要在渲染过程中读取或写入 ref.current</code>：通常渲染过程中需要某些信息，应该使用 state，而不是 ref。</li></ul></li></ul><h3 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h3><ul><li>ref 是一种脱围机制，用于保留不用于渲染的值。 你不会经常需要它们。</li><li>ref 是一个普通的 JavaScript 对象，具有一个名为 current 的属性，你可以对其进行读取或设置。</li><li>你可以通过调用 useRef Hook 来让 React 给你一个 ref。</li><li>与 state 一样，ref 允许你在组件的重新渲染之间保留信息。</li><li>与 state 不同，设置 ref 的 current 值不会触发重新渲染。</li><li>不要在渲染过程中读取或写入 ref.current。这使你的组件难以预测。</li></ul><h3 id="尝试一些挑战" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/referencing-values-with-refs#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>修复坏掉的聊天输入框</li><li>修复无法重新渲染的组件</li><li>修复防抖</li><li>读取最新的 state</li></ul></li></ul><h2 id="在-react-中怎样访问-dom" tabindex="-1"><a class="header-anchor" href="#在-react-中怎样访问-dom"><span>在 React 中怎样访问 DOM？</span></a></h2><ul><li>使用一个指向 DOM 节点的 ref 就可以访问 DOM，实现 DOM 节点获得焦点、滚动或测量它的尺寸和位置。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">useRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 最初 myRef.current 是 null</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> myRef</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">myRef</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">// 现在 可以使用浏览器 API 访问 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">myRef.current.scrollIntoView();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>怎样在循环中使用 ref？<a href="https://zh-hans.react.dev/reference/react-dom/components/common#ref-callback" target="_blank" rel="noopener noreferrer">ref 回调函数</a></li><li>如何访问另一个组件的 DOM 节点？ <ul><li>使用 <a href="https://zh-hans.react.dev/reference/react/forwardRef#reference" target="_blank" rel="noopener noreferrer">forwardRef</a> 让组件接收 ref 并将其传递给子组件</li></ul></li><li>React 何时添加 refs？ <ul><li>React 在提交阶段设置 ref.current</li><li>更新 DOM 之前，React 将受影响的 ref.current 设置为 null，DOM 更新后，立即设置 ref.current</li></ul></li><li><a href="https://zh-hans.react.dev/learn/queueing-a-series-of-state-updates" target="_blank" rel="noopener noreferrer">state 更新是排队进行的</a>：所以在修改 state 后，操作 ref 会出现落后的问题，怎么解决？ <ul><li><a href="https://zh-hans.react.dev/reference/react-dom/flushSync#reference" target="_blank" rel="noopener noreferrer">flushSync(callback)</a>，你应将其作为最后手段使用</li><li>示例：<a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync" target="_blank" rel="noopener noreferrer">用 flushSync 同步更新 state</a></li></ul></li><li>使用 refs 操作 DOM 的最佳实践 <ul><li>ref 是一种 React 的例外机制，应该在只有跳出 React 时使用，如：管理焦点、滚动位置，或调用 React 未暴露的浏览器 API 时使用。</li><li>如果你通过 ref 手动修改 DOM 可能会与 React 所做的更改发生冲突。</li><li>React 应用更改到 DOM，所以你可以通过 ref 修改 React 永远不会更改的部分就可以避免冲突。</li></ul></li></ul><h3 id="摘要-1" tabindex="-1"><a class="header-anchor" href="#摘要-1"><span>摘要</span></a></h3><ul><li>Refs 是一个通用概念，但大多数情况下你会使用它们来保存 DOM 元素。</li><li>你通过传递 <code>&lt;div ref={myRef}&gt;</code> 指示 React 将 DOM 节点放入 myRef.current。</li><li>通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。</li><li>默认情况下，组件不暴露其 DOM 节点。 你可以通过使用 forwardRef 并将第二个 ref 参数传递给特定节点来暴露 DOM 节点。</li><li>避免更改由 React 管理的 DOM 节点。</li><li>如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。</li></ul><h3 id="尝试一些挑战-1" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-1"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>播放和暂停视频</li><li>使搜索域获得焦点</li><li>滚动图像轮播</li><li>使分开的组件中的搜索域获得焦点</li></ul></li></ul><h2 id="怎样将组件与外部系统同步" tabindex="-1"><a class="header-anchor" href="#怎样将组件与外部系统同步"><span>怎样将组件与外部系统同步？</span></a></h2><ul><li>使用 Effect 进行同步，它允许你在渲染结束后执行一些代码。</li><li>回顾 React 组件逻辑 <ol><li>渲染代码：处理 props 和 state，是一种纯粹的计算结果</li><li>事件处理：处理用户事件，是一种副作用，通常会改变程序状态</li></ol></li><li>Effect 在 React 渲染提交应用到 DOM 后运行，是一种副作用。</li><li>如何编写 Effect，遵循三个步骤 <ol><li><code>声明 Effect</code>：在组件顶部调用 <a href="https://zh-hans.react.dev/reference/react/useEffect#reference" target="_blank" rel="noopener noreferrer"><code>useEffect</code></a></li></ol><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyComponent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 每次渲染提交后都会执行此处的代码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><code>指定 Effect 依赖</code>：useEffect() 第二个参数是一个依赖数组，只有当依赖项发生变化时，Effect 才会重新执行。</li></ol><ul><li>React 使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noopener noreferrer">Object.is</a> 来比较依赖项</li><li>你也不能随意选择依赖项，如果指定的依赖项与 React 根据 Effect 内部代码所推断出的依赖不匹配，你将收到来自 linter 的错误提示。</li></ul><ol start="3"><li><code>必要时添加清理操作</code>：useEffect 可以通过返回一个函数来执行清理操作。</li></ol><ul><li>避免在 Effect 中修改 state 防止死循环。因为 Effect 修改 state 又会触发组件的重新渲染，导致 Effect 再次执行，从而形成死循环。这时你也许不需要 Effect。</li></ul></li></ul><h3 id="摘要-2" tabindex="-1"><a class="header-anchor" href="#摘要-2"><span>摘要</span></a></h3><ul><li>与事件不同，Effect 由渲染本身引起，而非特定的交互。</li><li>Effect 允许你将组件与某些外部系统（第三方 API、网络等）同步。</li><li>默认情况下，Effect 在每次渲染（包括初始渲染）后运行。</li><li>如果所有依赖项都与上一次渲染时相同，React 会跳过本次 Effect。</li><li>你不能“选择”依赖项，它们是由 Effect 内部的代码所决定的。</li><li>空的依赖数组（[]）对应于组件的“挂载”，即组件被添加到页面上时。</li><li>仅在严格模式下的开发环境中，React 会挂载两次组件，以对 Effect 进行压力测试。</li><li>如果你的 Effect 因为重新挂载而出现问题，那么你需要实现一个清理函数。</li><li>React 会在 Effect 再次运行之前和在组件卸载时调用你的清理函数。</li></ul><h3 id="尝试一些挑战-2" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-2"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/synchronizing-with-effects#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>挂载后聚焦于表单字段</li><li>有条件地聚焦于表单字段</li><li>修复会触发两次的定时器</li><li>解决在 Effect 中获取数据的问题</li></ul></li></ul><h2 id="你可能不需要-effect" tabindex="-1"><a class="header-anchor" href="#你可能不需要-effect"><span>你可能不需要 Effect</span></a></h2><ul><li>如果你可以在渲染期间计算某些内容，则不需要使用 Effect。 <ul><li>如果没有涉及到外部系统，而只是根据 props 或 state 变化来更新组件，就不应该使用 Effect。因为 props 或 state 的变化本来就会触发 React 更新组件。</li><li>你不必使用 Effect 来处理用户事件，通常应该在相应的事件处理函数中处理用户事件。</li></ul></li><li>想要缓存昂贵的计算，请使用 <a href="https://zh-hans.react.dev/reference/react/useMemo" target="_blank" rel="noopener noreferrer">useMemo</a> 缓存一个昂贵的计算，而不是 useEffect。</li><li>想要重置整个组件树的 state，请传入不同的 key。</li><li>想要在 prop 变化时重置某些特定的 state，请在渲染期间处理。</li><li>组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中。</li><li>如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。</li><li>当你尝试在不同组件中同步 state 变量时，请考虑状态提升。</li><li>你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件。</li></ul><h3 id="尝试一些挑战-3" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-3"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/you-might-not-need-an-effect#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>第 1 个挑战 共 4 个挑战: 不用 Effect 转换数据</li><li>第 2 个挑战 共 4 个挑战: 不用 Effect 缓存计算结果</li><li>第 3 个挑战 共 4 个挑战: 不用 Effect 重置 state</li><li>第 4 个挑战 共 4 个挑战: 不用 Effect 提交表单</li></ul></li></ul><h2 id="effect-的生命周期-不同于-组件的生命周期" tabindex="-1"><a class="header-anchor" href="#effect-的生命周期-不同于-组件的生命周期"><span>Effect 的生命周期 不同于 组件的生命周期?</span></a></h2><ul><li>组件可以挂载、更新、卸载，但是 Effect 只能做两件事：<code>开始同步某些东西</code> 和 <code>停止同步它</code>。</li><li>Effect 如果依赖于随时间变化的 props 和 state，这个循环会发生多次。</li><li>Effect 和依赖项的关系 <ul><li>如果 Effect 没有进行任何同步操作，可能是不必要的。</li><li>如果它同时进行了几个独立的同步操作，因其依赖项是独立的，通常将 Effect 拆分为多个 Effect。</li><li>如果想读取 props 或 state 的最新值，又不想对 Effect 做出反应并重新同步，可以将 Effect 拆分为具有反应性的部分（保留在 Effect 中）和非反应性的部分（提取为名为 “Effect Event” 的内容）。</li><li>避免将对象和函数作为依赖项。如果在渲染过程中创建对象和函数，然后在 Effect 中读取它们，它们将在每次渲染时都不同。这将导致 Effect 每次都重新同步。</li></ul></li></ul><h3 id="摘要-3" tabindex="-1"><a class="header-anchor" href="#摘要-3"><span>摘要</span></a></h3><ul><li>组件可以挂载、更新和卸载。</li><li>每个 Effect 与周围组件有着独立的生命周期。</li><li>每个 Effect 描述了一个独立的同步过程，可以 <code>开始</code> 和 <code>停止</code>。</li><li>在编写和读取 Effect 时，要独立地考虑每个 Effect（如何开始和停止同步），而不是从组件的角度思考（如何挂载、更新或卸载）。</li><li>在组件主体内声明的值是“响应式”的。</li><li>响应式值应该重新进行同步 Effect，因为它们可以随着时间的推移而发生变化。</li><li>检查工具验证在 Effect 内部使用的所有响应式值都被指定为依赖项。</li><li>检查工具标记的所有错误都是合理的。总是有一种方法可以修复代码，同时不违反规则。</li></ul><h3 id="尝试一些挑战-4" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-4"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/lifecycle-of-reactive-effects#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>第 1 个挑战 共 5 个挑战: 修复每次输入均重新连接</li><li>第 2 个挑战 共 5 个挑战: 打开和关闭状态同步</li><li>第 3 个挑战 共 5 个挑战: 寻找过时值的错误</li><li>第 4 个挑战 共 5 个挑战: 修复连接开关</li><li>第 5 个挑战 共 5 个挑战: 填充一系列选择框</li></ul></li></ul><h2 id="将事件从-effect-中分开" tabindex="-1"><a class="header-anchor" href="#将事件从-effect-中分开"><span>将事件从 Effect 中分开</span></a></h2><ul><li>事件处理 和 Effect <table><thead><tr><th>事件处理</th><th>Effect</th></tr></thead><tbody><tr><td>在响应特定交互时运行</td><td>在依赖的 <code>props</code> 或 <code>state</code> 变化时运行</td></tr><tr><td>非响应式逻辑</td><td>响应式逻辑</td></tr></tbody></table></li><li>Effect Event <a href="https://zh-hans.react.dev/reference/react/experimental_useEffectEvent" target="_blank" rel="noopener noreferrer">useEffectEvent</a><ul><li>将非响应式逻辑从 Effect 移到 Effect Event 中，从而获取最新的 props 和 state</li><li>只在 Effect 内部调用 Effect Event。</li><li>不要将 Effect Event 传给其他组件或者 Hook。</li><li>永远在 useEffect 旁边声明 Effect Event<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用 useEffectEvent 创建 Effect Event，在 useEffect 的旁边</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> onMyHandle</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useEffectEvent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // useEffectEvent 中总是能访问最新的值</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 总是能访问最新的 props 和 state</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// args 可以没有，如果有的话通常是为了避免丢失 effect 触发时的值</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 如：effect 的依赖变化，那么 onMyHandle 中永远只能获取到当前值，而不是变化前的</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  onMyHandle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="尝试一些挑战-5" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-5"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/separating-events-from-effects#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>第 1 个挑战 共 4 个挑战: 修复一个不更新的变量</li><li>第 2 个挑战 共 4 个挑战: 修复一个冻结的计数器</li><li>第 3 个挑战 共 4 个挑战: 修复不可调整的延迟</li><li>第 4 个挑战 共 4 个挑战: 修复延迟通知</li></ul></li></ul><h2 id="移除-effect-的依赖项" tabindex="-1"><a class="header-anchor" href="#移除-effect-的依赖项"><span>移除 Effect 的依赖项</span></a></h2><ul><li>依赖应始终与代码匹配。</li><li>当你对依赖不满意时，你需要编辑的是代码。</li><li>抑制 linter 会导致非常混乱的错误，你应该始终避免它。</li><li>要移除依赖，你需要向 linter “证明”它不是必需的。</li><li>如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。</li><li>如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。</li><li>如果你想根据以前的状态更新一些状态，传递一个更新函数。</li><li>如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。</li><li>在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。</li><li>尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。</li></ul><h3 id="尝试一些挑战-6" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-6"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/removing-effect-dependencies#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>第 1 个挑战 共 4 个挑战: 修复重置 interval</li><li>第 2 个挑战 共 4 个挑战: 修复重新触发动画的问题</li><li>第 3 个挑战 共 4 个挑战: 修复聊天重新连接的问题</li><li>第 4 个挑战 共 4 个挑战: 再次修复聊天重新连接的问题</li></ul></li></ul>`,38)]))}const c=i(s,[["render",n],["__file","react-learn-04-escape.html.vue"]]),f=JSON.parse('{"path":"/code/fe/react/react-learn-04-escape.html","title":"React 脱围机制（Escape Hatches）","lang":"zh-CN","frontmatter":{"title":"React 脱围机制（Escape Hatches）","shortTitle":"React 脱围机制","icon":"magnet","date":"2024-12-06T14:46:36.000Z","category":["前端","react"],"tag":["react","escape"],"order":17,"description":"参考 React 官方文档 demo 怎样“记住”信息，而不触发重新渲染？ 可以使用 ref，它会记住信息，ref 的变更也不会触发新的渲染。 ref 和 state 的区别 何时使用 useRef？ 当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 timeout ID 存储和操作 DOM 元素 存储不需要被用来计算 JS...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/react/react-learn-04-escape.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"React 脱围机制（Escape Hatches）"}],["meta",{"property":"og:description","content":"参考 React 官方文档 demo 怎样“记住”信息，而不触发重新渲染？ 可以使用 ref，它会记住信息，ref 的变更也不会触发新的渲染。 ref 和 state 的区别 何时使用 useRef？ 当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 timeout ID 存储和操作 DOM 元素 存储不需要被用来计算 JS..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-11T02:48:07.000Z"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"escape"}],["meta",{"property":"article:published_time","content":"2024-12-06T14:46:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-11T02:48:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 脱围机制（Escape Hatches）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-06T14:46:36.000Z\\",\\"dateModified\\":\\"2024-12-11T02:48:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]},{"level":2,"title":"怎样“记住”信息，而不触发重新渲染？","slug":"怎样-记住-信息-而不触发重新渲染","link":"#怎样-记住-信息-而不触发重新渲染","children":[{"level":3,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战","link":"#尝试一些挑战","children":[]}]},{"level":2,"title":"在 React 中怎样访问 DOM？","slug":"在-react-中怎样访问-dom","link":"#在-react-中怎样访问-dom","children":[{"level":3,"title":"摘要","slug":"摘要-1","link":"#摘要-1","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-1","link":"#尝试一些挑战-1","children":[]}]},{"level":2,"title":"怎样将组件与外部系统同步？","slug":"怎样将组件与外部系统同步","link":"#怎样将组件与外部系统同步","children":[{"level":3,"title":"摘要","slug":"摘要-2","link":"#摘要-2","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-2","link":"#尝试一些挑战-2","children":[]}]},{"level":2,"title":"你可能不需要 Effect","slug":"你可能不需要-effect","link":"#你可能不需要-effect","children":[{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-3","link":"#尝试一些挑战-3","children":[]}]},{"level":2,"title":"Effect 的生命周期 不同于 组件的生命周期?","slug":"effect-的生命周期-不同于-组件的生命周期","link":"#effect-的生命周期-不同于-组件的生命周期","children":[{"level":3,"title":"摘要","slug":"摘要-3","link":"#摘要-3","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-4","link":"#尝试一些挑战-4","children":[]}]},{"level":2,"title":"将事件从 Effect 中分开","slug":"将事件从-effect-中分开","link":"#将事件从-effect-中分开","children":[{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-5","link":"#尝试一些挑战-5","children":[]}]},{"level":2,"title":"移除 Effect 的依赖项","slug":"移除-effect-的依赖项","link":"#移除-effect-的依赖项","children":[{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-6","link":"#尝试一些挑战-6","children":[]}]}],"git":{"createdTime":1733645746000,"updatedTime":1733885287000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":6}]},"readingTime":{"minutes":11.33,"words":3399},"filePathRelative":"code/fe/react/react-learn-04-escape.md","localizedDate":"2024年12月6日","excerpt":"<h2>参考</h2>\\n<ul>\\n<li><a href=\\"https://zh-hans.react.dev/learn/escape-hatches\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">React 官方文档</a></li>\\n<li><a href=\\"https://www.takeseem.com/demo-react/demo/react-escape\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">demo</a></li>\\n</ul>\\n<h2>怎样“记住”信息，而不触发重新渲染？</h2>\\n<ul>\\n<li>可以使用 <code>ref</code>，它会记住信息，ref 的变更也不会触发新的渲染。</li>\\n<li>ref 和 state 的区别\\n<table>\\n<thead>\\n<tr>\\n<th>ref</th>\\n<th>state</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><a href=\\"https://zh-hans.react.dev/reference/react/useRef#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">useRef</a></td>\\n<td><a href=\\"https://zh-hans.react.dev/reference/react/useState#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>useState</code></a></td>\\n</tr>\\n<tr>\\n<td>修改时不触发渲染</td>\\n<td>修改时触发渲染</td>\\n</tr>\\n<tr>\\n<td>可变，可以在渲染过程之外修改 current 的值</td>\\n<td>“不可变”，你必须使用 state setter 函数修改 state，从而排队重新渲染</td>\\n</tr>\\n<tr>\\n<td>不应在渲染期间读取、写入 current</td>\\n<td>可以随时读取 state，但每次渲染都有自己不变的 state 快照</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n<li>何时使用 <a href=\\"https://zh-hans.react.dev/reference/react/useRef#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">useRef</a>？\\n<ul>\\n<li>当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">timeout ID</a></li>\\n<li>存储和操作 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">DOM 元素</a></li>\\n<li>存储不需要被用来计算 JSX 的其他对象</li>\\n</ul>\\n</li>\\n<li>ref 的最佳实践\\n<ul>\\n<li><code>将 ref 视为脱围机制</code>：当使用外部系统或浏览器 API 时，如果应用程序逻辑和数据流很大一部分依赖于 ref，你可能需要重新考虑你的设计。</li>\\n<li><code>不要在渲染过程中读取或写入 ref.current</code>：通常渲染过程中需要某些信息，应该使用 state，而不是 ref。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,f as data};
