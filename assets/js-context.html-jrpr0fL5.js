import{_ as s,c as a,a as l,o as e}from"./app-CUzQWyjd.js";const n={};function t(h,i){return e(),a("div",null,i[0]||(i[0]=[l(`<p>JavaScript 中的 闭包 和 执行上下文 是理解语言运行机制的核心。要真正掌握这两个概念，必须从闭包的内部结构和执行上下文的执行过程出发。本文将通过生动的比喻和实际例子，帮助你轻松理解这两个重要概念。</p><h2 id="一、闭包-一个拥有记忆的-盒子" tabindex="-1"><a class="header-anchor" href="#一、闭包-一个拥有记忆的-盒子"><span>一、闭包：一个拥有记忆的“盒子”</span></a></h2><p>闭包不仅仅是一个函数，它包含了两个核心部分：环境部分 和 表达式部分。形象地来说，闭包就像一个带有记忆功能的“盒子”。</p><ol><li>环境部分</li></ol><blockquote><p>环境部分 保存了闭包捕获的外部变量和函数——这就像盒子外面的东西，被“记住”并在闭包内随时可以访问。</p></blockquote><ol start="2"><li>表达式部分</li></ol><blockquote><p>表达式部分 是盒子内部的代码逻辑，也就是实际的函数表达式。它依赖于环境部分存储的信息来执行操作。</p></blockquote><p>举个例子：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> outerVar</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;I am from the outer function&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> inner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">outerVar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 闭包捕获了外部变量 outerVar</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  };</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> closure</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> outer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">closure</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 输出: I am from the outer function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，inner 函数形成了一个闭包，outerVar 被捕获并在 inner 中使用，哪怕 outer 函数已经执行完毕。</p><h2 id="二、执行上下文-代码执行的幕后操作" tabindex="-1"><a class="header-anchor" href="#二、执行上下文-代码执行的幕后操作"><span>二、执行上下文：代码执行的幕后操作</span></a></h2><p>执行上下文 是 JavaScript 运行一段代码所需的所有信息的集合。每一段代码（包括函数）都会创建一个独立的执行上下文。</p><ol><li>三种执行上下文</li></ol><ul><li>全局执行上下文：默认创建，包含全局代码的执行环境。</li><li>函数执行上下文：每当函数调用时，都会为该函数创建一个新的执行上下文。</li><li>Eval 执行上下文：eval() 函数执行时会生成专用的执行上下文（不建议使用 eval）。</li></ul><ol start="2"><li>执行上下文的创建阶段</li></ol><blockquote><p>当代码开始执行时，JavaScript 引擎会经历创建阶段，包括以下步骤：</p></blockquote><ul><li>设置作用域链：当前执行上下文和所有父级上下文中的变量对象都被放入作用域链。</li><li>变量对象：存储当前上下文中的变量和函数声明。</li><li>This 绑定：定义 this 的指向。</li></ul><h2 id="三、深入剖析作用域链和-this-绑定" tabindex="-1"><a class="header-anchor" href="#三、深入剖析作用域链和-this-绑定"><span>三、深入剖析作用域链和 this 绑定</span></a></h2><ol><li>作用域链</li></ol><blockquote><p>作用域链是当前执行上下文及其所有上级执行上下文中变量的集合。它决定了函数在不同执行阶段能访问的变量。</p></blockquote><ol start="2"><li>this 绑定</li></ol><blockquote><p>this 的指向在不同的上下文中有不同的表现：</p></blockquote><ul><li>全局上下文：this 指向全局对象（浏览器中是 window）。</li><li>函数上下文：根据函数的调用方式不同，this 的指向会有所不同： <ul><li>普通函数：this 指向全局对象。</li><li>对象方法：this 指向调用该方法的对象。</li><li>使用 new 调用构造函数：this 指向新创建的对象。</li><li>使用 call 或 apply：this 绑定到传入的对象。</li></ul></li></ul><h2 id="四、执行上下文栈-后进先出的执行流" tabindex="-1"><a class="header-anchor" href="#四、执行上下文栈-后进先出的执行流"><span>四、执行上下文栈：后进先出的执行流</span></a></h2><p>JavaScript 中的执行上下文是以**栈（stack）**的形式管理的。栈遵循 后进先出（LIFO） 的原则：</p><ol><li>执行全局代码，创建全局执行上下文并压入栈底。</li><li>调用一个函数时，创建一个新的函数执行上下文，并压入栈顶</li><li>函数执行后，栈顶的执行上下文被弹出，返回上一个上下文继续执行</li></ol><p>举例说明：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;First function&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> second</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;Second function&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">first</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行过程：</p><ol><li>全局执行上下文入栈。</li><li>调用 first 函数，first 执行上下文入栈，执行 console.log。</li><li>调用 second 函数，second 执行上下文入栈，执行 console.log。</li><li>second 执行完毕，出栈。</li><li>first 执行完毕，出栈。</li></ol><p>最终的输出是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>First function</span></span>
<span class="line"><span>Second function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="五、总结-掌握闭包与执行上下文的关键" tabindex="-1"><a class="header-anchor" href="#五、总结-掌握闭包与执行上下文的关键"><span>五、总结：掌握闭包与执行上下文的关键</span></a></h2><p>理解 闭包 和 执行上下文，能帮助你更好地写出高效、稳定的 JavaScript 代码。闭包为你的函数赋予了记忆功能，而执行上下文决定了代码的执行顺序和 this 的绑定。通过掌握这些机制，你将能更灵活地管理 JavaScript 的异步操作、变量作用域和函数调用。</p><p>如果你觉得这篇文章对你有帮助，别忘了收藏和分享给你的朋友！💡</p>`,35)]))}const r=s(n,[["render",t],["__file","js-context.html.vue"]]),k=JSON.parse('{"path":"/code/fe/js-context.html","title":"彻底搞懂闭包和执行上下文：从盒子到执行栈的深度解析","lang":"zh-CN","frontmatter":{"title":"彻底搞懂闭包和执行上下文：从盒子到执行栈的深度解析","shortTitle":"深入理解闭包和执行上下文","icon":"c","date":"2024-09-23T20:55:32.000Z","category":["前端","js"],"tag":["js"],"order":50,"description":"JavaScript 中的 闭包 和 执行上下文 是理解语言运行机制的核心。要真正掌握这两个概念，必须从闭包的内部结构和执行上下文的执行过程出发。本文将通过生动的比喻和实际例子，帮助你轻松理解这两个重要概念。 一、闭包：一个拥有记忆的“盒子” 闭包不仅仅是一个函数，它包含了两个核心部分：环境部分 和 表达式部分。形象地来说，闭包就像一个带有记忆功能的“...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/js-context.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"彻底搞懂闭包和执行上下文：从盒子到执行栈的深度解析"}],["meta",{"property":"og:description","content":"JavaScript 中的 闭包 和 执行上下文 是理解语言运行机制的核心。要真正掌握这两个概念，必须从闭包的内部结构和执行上下文的执行过程出发。本文将通过生动的比喻和实际例子，帮助你轻松理解这两个重要概念。 一、闭包：一个拥有记忆的“盒子” 闭包不仅仅是一个函数，它包含了两个核心部分：环境部分 和 表达式部分。形象地来说，闭包就像一个带有记忆功能的“..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-05T02:09:58.000Z"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:published_time","content":"2024-09-23T20:55:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-05T02:09:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"彻底搞懂闭包和执行上下文：从盒子到执行栈的深度解析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-23T20:55:32.000Z\\",\\"dateModified\\":\\"2024-11-05T02:09:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"一、闭包：一个拥有记忆的“盒子”","slug":"一、闭包-一个拥有记忆的-盒子","link":"#一、闭包-一个拥有记忆的-盒子","children":[]},{"level":2,"title":"二、执行上下文：代码执行的幕后操作","slug":"二、执行上下文-代码执行的幕后操作","link":"#二、执行上下文-代码执行的幕后操作","children":[]},{"level":2,"title":"三、深入剖析作用域链和 this 绑定","slug":"三、深入剖析作用域链和-this-绑定","link":"#三、深入剖析作用域链和-this-绑定","children":[]},{"level":2,"title":"四、执行上下文栈：后进先出的执行流","slug":"四、执行上下文栈-后进先出的执行流","link":"#四、执行上下文栈-后进先出的执行流","children":[]},{"level":2,"title":"五、总结：掌握闭包与执行上下文的关键","slug":"五、总结-掌握闭包与执行上下文的关键","link":"#五、总结-掌握闭包与执行上下文的关键","children":[]}],"git":{"createdTime":1730772598000,"updatedTime":1730772598000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":1}]},"readingTime":{"minutes":3.9,"words":1169},"filePathRelative":"code/fe/js-context.md","localizedDate":"2024年9月23日","excerpt":"<p>JavaScript 中的 闭包 和 执行上下文 是理解语言运行机制的核心。要真正掌握这两个概念，必须从闭包的内部结构和执行上下文的执行过程出发。本文将通过生动的比喻和实际例子，帮助你轻松理解这两个重要概念。</p>\\n<h2>一、闭包：一个拥有记忆的“盒子”</h2>\\n<p>闭包不仅仅是一个函数，它包含了两个核心部分：环境部分 和 表达式部分。形象地来说，闭包就像一个带有记忆功能的“盒子”。</p>\\n<ol>\\n<li>环境部分</li>\\n</ol>\\n<blockquote>\\n<p>环境部分 保存了闭包捕获的外部变量和函数——这就像盒子外面的东西，被“记住”并在闭包内随时可以访问。</p>\\n</blockquote>","autoDesc":true}');export{r as comp,k as data};
