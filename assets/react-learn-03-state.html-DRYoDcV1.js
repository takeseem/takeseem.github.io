import{_ as s,c as e,a,o as t}from"./app--2wf5hGV.js";const l="/assets/react-learn-03-state-1-o4Sg5sdt.png",n="/assets/react-learn-03-state-2-zf8AFDR7.png",h="/assets/react-learn-03-state-3-CA6Ndw2p.png",r={};function k(d,i){return t(),e("div",null,i[0]||(i[0]=[a('<h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://zh-hans.react.dev/learn/managing-state" target="_blank" rel="noopener noreferrer">React 官方文档</a></li><li><a href="https://www.takeseem.com/demo-react/demo/react-state" target="_blank" rel="noopener noreferrer">demo</a></li></ul><h2 id="将-ui-视为-state" tabindex="-1"><a class="header-anchor" href="#将-ui-视为-state"><span>将 UI 视为 state</span></a></h2><h3 id="声明式-ui-编程与命令式-ui-编程有何不同" tabindex="-1"><a class="header-anchor" href="#声明式-ui-编程与命令式-ui-编程有何不同"><span>声明式 UI 编程与命令式 UI 编程有何不同？</span></a></h3><ul><li>命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 <ul><li>他不知道你想要去哪儿，所以他只能根据你的指令来行动。</li><li>你必须知道执行的每个细节和步骤，并处理每个可能的错误。</li></ul></li><li>声明式编程：你告诉他要去哪儿，然后他去了。 <ul><li>你只需告诉他要去哪儿，而不是事无巨细的告诉他如何走，他就会将你带到目的地。</li><li>你只需声明你想要的，React 会计算出如何去更新 UI。</li></ul></li></ul><h3 id="怎样声明式地考虑-ui" tabindex="-1"><a class="header-anchor" href="#怎样声明式地考虑-ui"><span>怎样声明式地考虑 UI？</span></a></h3><ol><li><code>定位</code>你的组件中不同的视图状态</li></ol><ul><li>如表单：未填写、输入中、提交中、成功时、错误时。</li></ul><ol start="2"><li><code>确定</code>是什么触发了这些 <code>state</code> 的改变</li></ol><ul><li>人为输入：点击、填写内容、点击导航链接等，通常需要：<a href="https://zh-hans.react.dev/learn/responding-to-events" target="_blank" rel="noopener noreferrer">事件处理函数</a></li><li>计算机输入：网络请求反馈、定时器、加载图片等。</li><li>如：表单的各种状态： <img src="'+l+`" alt="表单的各种状态" loading="lazy"></li></ul><ol start="3"><li><code>表示</code>内存中的 state（需要使用 <code>useState</code>）</li><li><code>删除</code>任何不必要的 state 变量</li></ol><ul><li>怎样找出不必要的 state 变量？问问自己： <ul><li><code>这个 state 是否会导致矛盾？</code>例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，你可以将他们合并到一个 &#39;status&#39; 中，它的值必须是 &#39;typing&#39;、&#39;submitting&#39; 以及 &#39;success&#39; 这三个中的一个。</li><li><code>相同的信息是否已经在另一个 state 变量中存在？</code>另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，你可以移除 isEmpty 转而用 message.length === 0。</li><li><code>你是否可以通过另一个 state 变量的相反值得到相同的信息？</code>isError 是多余的，因为你可以检查 error !== null。</li></ul></li><li>通过 <a href="https://zh-hans.react.dev/learn/extracting-state-logic-into-a-reducer" target="_blank" rel="noopener noreferrer">将状态提取到一个 reducer 中</a> 减少“不可能” state</li></ul><ol start="5"><li><code>连接</code>事件处理函数去设置 state</li></ol><h3 id="尝试一些挑战" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/reacting-to-input-with-state#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a>：务必 Fork 再修复以避免内嵌导致的一些莫名其妙错误。 <ul><li><code>添加和删除一个 CSS class</code> 收获：useState 的使用，事件冒泡。</li><li><code>个人信息编辑器</code> 收获：React 很简单，form submit 默认行为处理。</li><li><code>不使用 React 去重构命令式的解决方案</code> 收获：怎样用 JS 直接操作 DOM，深刻体会 React 的优势。</li></ul></li></ul><h2 id="如何组织好-state-状态结构" tabindex="-1"><a class="header-anchor" href="#如何组织好-state-状态结构"><span>如何组织好 state 状态结构？</span></a></h2><h3 id="state-构建原则" tabindex="-1"><a class="header-anchor" href="#state-构建原则"><span>state 构建原则</span></a></h3><ol><li><code>合并关联的 state</code>：如果总是同时更新两个或更多 state，考虑将它们合为一个单独的 state 变量。</li><li><code>避免矛盾的 state</code>：应尽量避免 state 结构中存在多个相互矛盾或“不一致”的 state。</li><li><code>避免冗余的 state</code>：如果能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入 state 中。</li><li><code>避免重复的 state</code>：当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，很难保持它们同步。应尽可能减少重复。</li><li><code>避免深度嵌套的 state</code>：深度分层的 state 更新起来不方便，最好以扁平化方式构建 state。有时候可以将一些嵌套 state 移动到子组件中来减少 state 的嵌套，通常是不需要保持的短暂 UI 状态，如：一个选项是否被悬停。</li></ol><h3 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h3><ul><li>如果两个 state 变量总是一起更新，请考虑将它们合并为一个。</li><li>仔细选择你的 state 变量，以避免创建“极难处理”的 state。</li><li>用一种减少出错更新的机会的方式来构建你的 state。</li><li>避免冗余和重复的 state，这样你就不需要保持同步。</li><li>除非你特别想防止更新，否则不要将 props 放入 state 中。</li><li>对于选择类型的 UI 模式，请在 state 中保存 ID 或索引而不是对象本身。</li><li>如果深度嵌套 state 更新很复杂，请尝试将其展开扁平化。</li></ul><h3 id="尝试一些挑战-1" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-1"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/choosing-the-state-structure#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a> 务必 Fork 再修复以避免内嵌导致的一些莫名其妙错误。 <ul><li>修复一个未更新的组件：因为定义了非必要的 state。</li><li>修复一个损坏的打包清单：total 和 packed 是可计算的，无须定义 state。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setItems</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initialItems</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> total</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> packed</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forEach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">v</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">packed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">packed</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>修复消失的选项 <ul><li>因为比较的是对象：<code>isHighlighted={letter === highlightedLetter}</code>，而点击后是一个新对象，肯定不相等</li><li>修复：应比较对象的标识：<code>isHighlighted={letter.id === highlightedLetter?.id}</code>，注意首次高亮对象是 null</li></ul></li><li>实现多选功能：如果熟悉 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">Array API</a> 很快就能实现 <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">findIndex</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced" target="_blank" rel="noopener noreferrer">toSpliced</a></li></ul><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setSelectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> selectedCount</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handleToggle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> idx</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">findIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  setSelectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    idx</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      ?</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toSpliced</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      :</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toSpliced</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">idx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="如何使用-状态提升-在组件之间共享状态" tabindex="-1"><a class="header-anchor" href="#如何使用-状态提升-在组件之间共享状态"><span>如何使用“状态提升”在组件之间共享状态</span></a></h2><ul><li>把 state 放到它们的公共父级——这被称为“状态提升”</li><li>如何使用状态提升在组件之间共享状态</li><li>什么是受控组件和非受控组件 <ul><li><code>非受控组件</code>：组件由其自身内部状态控制的叫非受控组件。</li><li><code>受控组件</code>：组件由 <code>props</code> 输入控制的就叫受控组件。</li></ul></li></ul><h3 id="尝试一些挑战-2" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-2"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/sharing-state-between-components#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>挑战: 同步输入状态</li><li>挑战: 列表过滤</li></ul></li></ul><h2 id="如何控制状态的保留或重置" tabindex="-1"><a class="header-anchor" href="#如何控制状态的保留或重置"><span>如何控制状态的保留或重置</span></a></h2><ul><li>React 何时保留或重置 state <ul><li>React <a href="https://zh-hans.react.dev/learn/understanding-your-ui-as-a-tree#the-render-tree" target="_blank" rel="noopener noreferrer">渲染树</a></li><li>React 组件 state 和 渲染是一一对应的，渲染时会创建 state，一旦被替换或移除就会销毁 state。</li><li>注意：<code>对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！</code>也就是说位于相同位置的相同组件，对 React 来说，它就是同一个组件。</li></ul></li><li>如何强制 React 重置组件的状态 <ul><li>方法一：将组件渲染在不同的位置，这里每一对<code>{}</code>就是一个位置<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">isPlayerA</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Player</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player A&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    }</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    {</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">isPlayerA</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Player</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player B&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;/&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>方法二：使用 key 来重置 state，key 来让 React 区分任何组件，注意：key 不必全局唯一，它只是用于 <code>父组件内部</code> 区分组件的标识。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">isPlayerA</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      ?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Player</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player A&quot;</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player A&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      :</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Player</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player B&quot;</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Player B&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#CA1243;--shiki-dark:#C678DD;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  &lt;/&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>为被移除的组件保留 state <ul><li>方法一：利用 CSS 隐藏起来，缺点：在复杂的 UI 中 DOM 依然存在，存在性能问题。</li><li>方法二：状态提升到父组件中，这是常见的解决办法</li><li>方法三：状态保存到 <code>localStorage</code></li></ul></li></ul><h3 id="摘要-1" tabindex="-1"><a class="header-anchor" href="#摘要-1"><span>摘要</span></a></h3><ul><li>只要在相同位置渲染的是相同组件， React 就会保留状态。</li><li>state 不会被保存在 JSX 标签里。它与你在树中放置该 JSX 的位置相关联。</li><li>你可以通过为一个子树指定一个不同的 key 来重置它的 state。</li><li>不要嵌套组件的定义，否则你会意外地导致 state 被重置。</li></ul><h3 id="尝试一些挑战-3" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-3"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/preserving-and-resetting-state#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>修复丢失的输入框文本：通过保持输入框组件位置不变来修复。</li><li>交换两个表单字段：通过设置组件 key 从而区分组件并保持其 state。</li><li>重置详情表单：</li><li>清除正在加载的图片</li><li>修复列表中错位的 state</li></ul></li></ul><h2 id="如何在函数中整合复杂的状态逻辑" tabindex="-1"><a class="header-anchor" href="#如何在函数中整合复杂的状态逻辑"><span>如何在函数中整合复杂的状态逻辑？</span></a></h2><h3 id="usereducer" tabindex="-1"><a class="header-anchor" href="#usereducer"><span>useReducer</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当有许多状态变更逻辑时，事件处理会过于分散，你可以将组件的所有状态处理逻辑整合到一个 <code>reducer</code> 函数中。</p></div><ul><li><a href="https://zh-hans.react.dev/reference/react/useReducer" target="_blank" rel="noopener noreferrer"><code>useReducer</code></a></li><li>如何编写一个好的 <code>reducer</code><ul><li><code>reducer 必须是纯粹的</code>：reducer 是在渲染时运行的，actions 会排队直到下一次渲染。<code>纯粹</code>：即当输入相同时，输出也是相同的，不应包含异步请求、定时器或者任何副作用（对组件外部有影响的操作），应该以不可变值的方式更新 <code>对象</code> 和 <code>数组</code>。</li><li><code>每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化</code>：举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果你在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能让你以某种步骤复现已发生的交互或响应。这对代码调试很有帮助！</li></ul></li><li>使用 Immer 简化 reducer：<a href="https://github.com/immerjs/use-immer#useimmerreducer" target="_blank" rel="noopener noreferrer"><code>useImmerReducer</code></a></li></ul><h3 id="摘要-2" tabindex="-1"><a class="header-anchor" href="#摘要-2"><span>摘要</span></a></h3><ul><li>用：<a href="https://zh-hans.react.dev/reference/react/useReducer" target="_blank" rel="noopener noreferrer"><code>useReducer</code></a> 替换 <code>useState</code><ol><li>通过事件处理函数 dispatch actions；</li><li>编写一个 reducer 函数，它接受传入的 state 和一个 action，并返回一个新的 state；</li><li>使用 useReducer 替换 useState；</li></ol></li><li>Reducer 可能需要你写更多的代码，但是这有利于代码的调试和测试。</li><li>Reducer 必须是纯净的。</li><li>每个 action 都描述了一个单一的用户交互。</li><li>使用 <a href="https://github.com/immerjs/use-immer#useimmerreducer" target="_blank" rel="noopener noreferrer"><code>useImmerReducer</code></a> 来帮助你在 reducer 里直接修改状态。</li></ul><h3 id="尝试一些挑战-4" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-4"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/extracting-state-logic-into-a-reducer#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>通过事件处理函数 dispatch actions</li><li>发送消息时清空输入框</li><li>切换 tab 时重置输入框内容</li><li>从零开始实现 <code>useReducer</code><ul><li><code>reducer</code> 接受两个参数：<code>state</code> 当前状态，<code>action</code> 当前动作及其数据</li><li><code>reducer</code> 返回新状态</li></ul><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useReducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">reducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">initialState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initialState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dispatch</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">action</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    setState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reducer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">action</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">state</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">dispatch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="如何避免数据通过-props-逐级透传" tabindex="-1"><a class="header-anchor" href="#如何避免数据通过-props-逐级透传"><span>如何避免数据通过 props 逐级透传？</span></a></h2><ul><li>如果某个 <code>state</code> 状态分布在组件树的多个叶子节点，按状态提升逻辑，将出现逐层提升，状态将通过 props 逐层透传。 <img src="`+n+'" alt="props 透传" loading="lazy"></li><li><a href="https://zh-hans.react.dev/learn/passing-data-deeply-with-context" target="_blank" rel="noopener noreferrer">Context</a>：传递 props 的另一种方法，Context 可以让父节点，甚至是很远的父节点都可以为其内部的整个组件树提供数据。 <img src="'+h+`" alt="使用 context" loading="lazy"></li><li>使用步骤 <ol><li><code>创建</code>一个 context <a href="https://zh-hans.react.dev/reference/react/createContext" target="_blank" rel="noopener noreferrer">createContext</a></li></ol><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> LevelContext</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>在需要数据的组件内 <code>使用</code> context <a href="https://zh-hans.react.dev/reference/react/useContext" target="_blank" rel="noopener noreferrer">useContext</a></li></ol><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Heading</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> level</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">LevelContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>在指定数据的组件中 <code>提供</code> 这个 context，用 context provider 包裹起来 提供 LevelContext</li></ol><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Section</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">level</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">section</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> className</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;section&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">LevelContext.Provider</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">level</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">        {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">children</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;/</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">LevelContext.Provider</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">section</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="如何避免滥用-context" tabindex="-1"><a class="header-anchor" href="#如何避免滥用-context"><span>如何避免滥用 context？</span></a></h3><div class="hint-container tip"><p class="hint-container-title">可以先考虑以下几种替代方案</p><ul><li><a href="https://zh-hans.react.dev/learn/passing-props-to-a-component" target="_blank" rel="noopener noreferrer">使用 props 传递</a>：通过十几个组件向下传递一堆 props 并不罕见，这就像埋头苦干，props 让数据流变得清晰。</li><li>抽象组件并将 <a href="https://zh-hans.react.dev/learn/passing-props-to-a-component#passing-jsx-as-children" target="_blank" rel="noopener noreferrer">JSX 作为 children 传递</a>，如：<code>&lt;Layout posts={posts} /&gt;</code> 中 <code>posts</code> 的传递是否可以转换为 <code>children</code>：<code>&lt;Layout&gt;&lt;Posts posts={posts} /&gt;&lt;/Layout&gt;</code></li><li>如果这两种方案都不适合时，再考虑使用 context</li></ul></div><h3 id="context-的使用场景" tabindex="-1"><a class="header-anchor" href="#context-的使用场景"><span>context 的使用场景</span></a></h3><ul><li><code>主题：</code> 通常在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。</li><li><code>当前账户：</code>将当前登录用户信息放到 context 中，可方便地在任何位置读取它。某些应用还允许你同时操作多个账户（例如，以不同用户的身份发表评论）。在这些情况下，将 UI 的一部分包裹到具有不同账户数据的 provider 中会很方便。</li><li><code>路由：</code>大多数路由方案在其内部用 context 来保存当前路由。这就是每个链接“知道”它是否处于活动状态的方式。</li><li><code>状态管理：</code> 随着应用增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件如果想要修改它们，通常 将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。</li></ul><p>Context 不局限于静态值。如果你在下一次渲染时传递不同的值，React 将会更新读取它的所有下层组件！这就是 context 经常和 state 结合使用的原因。</p><p>如果树中不同部分的远距离组件需要某些信息，context 将会对你大有帮助。</p><h3 id="摘要-3" tabindex="-1"><a class="header-anchor" href="#摘要-3"><span>摘要</span></a></h3><ul><li>Context 使组件向其下方的整个树提供信息。</li><li>传递 Context 的方法: <ol><li>通过 <code>export const MyContext = createContext(defaultValue)</code> 创建并导出 context。</li><li>在无论层级多深的任何子组件中，把 context 传递给 <code>useContext(MyContext)</code> Hook 来读取它。</li><li>在父组件中把 children 包在 <code>&lt;MyContext.Provider value={...}&gt;</code> 中来提供 context。</li></ol></li><li>Context 会穿过中间的任何组件。</li><li>Context 可以让你写出 “较为通用” 的组件。</li><li>在使用 context 之前，先试试传递 props 或者将 JSX 作为 children 传递。</li></ul><h3 id="尝试一些挑战-5" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-5"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/passing-data-deeply-with-context#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>用 context 替代逐层 props</li></ul></li></ul><h2 id="如何结合使用-reducer-和-context" tabindex="-1"><a class="header-anchor" href="#如何结合使用-reducer-和-context"><span>如何结合使用 <code>reducer</code> 和 <code>context</code>？</span></a></h2><ul><li>用 <a href="https://zh-hans.react.dev/reference/react/useReducer" target="_blank" rel="noopener noreferrer"><code>useReducer</code></a> 整合状态更新逻辑</li><li>用 <a href="https://zh-hans.react.dev/reference/react/useContext" target="_blank" rel="noopener noreferrer"><code>useContext</code></a> 将信息跨组件树传递给深层次的组件</li><li>如何结合使用 <code>reducer</code> 和 <code>context</code>？ <ol><li>创建 context：<a href="https://zh-hans.react.dev/reference/react/createContext" target="_blank" rel="noopener noreferrer"><code>createContext</code></a></li><li>将 state 和 dispatch 放入 context：<a href="https://zh-hans.react.dev/reference/react/createContext#provider" target="_blank" rel="noopener noreferrer">Provider</a></li><li>在组件树的任何地方 使用 context：<a href="https://zh-hans.react.dev/reference/react/useContext" target="_blank" rel="noopener noreferrer"><code>useContext</code></a></li></ol></li></ul><h3 id="摘要-4" tabindex="-1"><a class="header-anchor" href="#摘要-4"><span>摘要</span></a></h3><ul><li>你可以将 reducer 与 context 相结合，让任何组件读取和更新它的状态。</li><li>为子组件提供 state 和 dispatch 函数： <ol><li>创建两个 context (一个用于 state,一个用于 dispatch 函数)。</li><li>让组件的 context 使用 reducer。</li><li>使用组件中需要读取的 context。</li></ol></li><li>你可以通过将所有传递信息的代码移动到单个文件中来进一步整理组件。 <ul><li>你可以导出一个像 TasksProvider 可以提供 context 的组件。</li><li>你也可以导出像 useTasks 和 useTasksDispatch 这样的自定义 Hook。</li></ul></li><li>你可以在你的应用程序中大量使用 context 和 reducer 的组合。</li></ul><h3 id="尝试一些挑战-6" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-6"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方的：<a href="https://zh-hans.react.dev/learn/scaling-up-with-reducer-and-context#combining-a-reducer-with-context" target="_blank" rel="noopener noreferrer">结合使用示例</a><ul><li><a href="https://www.takeseem.com/demo-react/demo/react-state#useReducerAndContext" target="_blank" rel="noopener noreferrer">demo</a></li><li><a href="https://github.com/takeseem/demo-react/commits/0908b9f15c0ece1a7b32e77aa249168bf7922b71/" target="_blank" rel="noopener noreferrer">官方代码 示例</a></li><li><a href="https://github.com/takeseem/demo-react/tree/5c6b452a8e99b2e61919d8d7f42974b396c73b82" target="_blank" rel="noopener noreferrer">最终代码</a></li></ul></li></ul>`,58)]))}const c=s(r,[["render",k],["__file","react-learn-03-state.html.vue"]]),o=JSON.parse('{"path":"/code/fe/react/react-learn-03-state.html","title":"React 状态管理","lang":"zh-CN","frontmatter":{"title":"React 状态管理","icon":"store","date":"2024-12-03T14:22:36.000Z","category":["前端","react"],"tag":["react","state"],"order":17,"description":"参考 React 官方文档 demo 将 UI 视为 state 声明式 UI 编程与命令式 UI 编程有何不同？ 命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 他不知道你想要去哪儿，所以他只能根据你的指令来行动。 你必须知道执行的每个细节和步骤，并处理每个可能的错误。 声明式编程：你告诉他要去哪儿，然后他去了。 你只需告诉他要去哪儿，而不是事...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/react/react-learn-03-state.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"React 状态管理"}],["meta",{"property":"og:description","content":"参考 React 官方文档 demo 将 UI 视为 state 声明式 UI 编程与命令式 UI 编程有何不同？ 命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 他不知道你想要去哪儿，所以他只能根据你的指令来行动。 你必须知道执行的每个细节和步骤，并处理每个可能的错误。 声明式编程：你告诉他要去哪儿，然后他去了。 你只需告诉他要去哪儿，而不是事..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-06T06:26:48.000Z"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"state"}],["meta",{"property":"article:published_time","content":"2024-12-03T14:22:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-06T06:26:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 状态管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-03T14:22:36.000Z\\",\\"dateModified\\":\\"2024-12-06T06:26:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]},{"level":2,"title":"将 UI 视为 state","slug":"将-ui-视为-state","link":"#将-ui-视为-state","children":[{"level":3,"title":"声明式 UI 编程与命令式 UI 编程有何不同？","slug":"声明式-ui-编程与命令式-ui-编程有何不同","link":"#声明式-ui-编程与命令式-ui-编程有何不同","children":[]},{"level":3,"title":"怎样声明式地考虑 UI？","slug":"怎样声明式地考虑-ui","link":"#怎样声明式地考虑-ui","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战","link":"#尝试一些挑战","children":[]}]},{"level":2,"title":"如何组织好 state 状态结构？","slug":"如何组织好-state-状态结构","link":"#如何组织好-state-状态结构","children":[{"level":3,"title":"state 构建原则","slug":"state-构建原则","link":"#state-构建原则","children":[]},{"level":3,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-1","link":"#尝试一些挑战-1","children":[]}]},{"level":2,"title":"如何使用“状态提升”在组件之间共享状态","slug":"如何使用-状态提升-在组件之间共享状态","link":"#如何使用-状态提升-在组件之间共享状态","children":[{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-2","link":"#尝试一些挑战-2","children":[]}]},{"level":2,"title":"如何控制状态的保留或重置","slug":"如何控制状态的保留或重置","link":"#如何控制状态的保留或重置","children":[{"level":3,"title":"摘要","slug":"摘要-1","link":"#摘要-1","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-3","link":"#尝试一些挑战-3","children":[]}]},{"level":2,"title":"如何在函数中整合复杂的状态逻辑？","slug":"如何在函数中整合复杂的状态逻辑","link":"#如何在函数中整合复杂的状态逻辑","children":[{"level":3,"title":"useReducer","slug":"usereducer","link":"#usereducer","children":[]},{"level":3,"title":"摘要","slug":"摘要-2","link":"#摘要-2","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-4","link":"#尝试一些挑战-4","children":[]}]},{"level":2,"title":"如何避免数据通过 props 逐级透传？","slug":"如何避免数据通过-props-逐级透传","link":"#如何避免数据通过-props-逐级透传","children":[{"level":3,"title":"如何避免滥用 context？","slug":"如何避免滥用-context","link":"#如何避免滥用-context","children":[]},{"level":3,"title":"context 的使用场景","slug":"context-的使用场景","link":"#context-的使用场景","children":[]},{"level":3,"title":"摘要","slug":"摘要-3","link":"#摘要-3","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-5","link":"#尝试一些挑战-5","children":[]}]},{"level":2,"title":"如何结合使用 reducer 和 context？","slug":"如何结合使用-reducer-和-context","link":"#如何结合使用-reducer-和-context","children":[{"level":3,"title":"摘要","slug":"摘要-4","link":"#摘要-4","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-6","link":"#尝试一些挑战-6","children":[]}]}],"git":{"createdTime":1733318013000,"updatedTime":1733466408000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":3}]},"readingTime":{"minutes":12.53,"words":3760},"filePathRelative":"code/fe/react/react-learn-03-state.md","localizedDate":"2024年12月3日","excerpt":"<h2>参考</h2>\\n<ul>\\n<li><a href=\\"https://zh-hans.react.dev/learn/managing-state\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">React 官方文档</a></li>\\n<li><a href=\\"https://www.takeseem.com/demo-react/demo/react-state\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">demo</a></li>\\n</ul>\\n<h2>将 UI 视为 state</h2>\\n<h3>声明式 UI 编程与命令式 UI 编程有何不同？</h3>","autoDesc":true}');export{c as comp,o as data};
