import{_ as t,c as a,a as i,o as s}from"./app-CoTLfwe8.js";const l={};function r(n,e){return s(),a("div",null,e[0]||(e[0]=[i(`<h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://zh-hans.react.dev/learn/escape-hatches" target="_blank" rel="noopener noreferrer">React 官方文档</a></li><li><a href="https://www.takeseem.com/demo-react/demo/react-escape" target="_blank" rel="noopener noreferrer">demo</a></li></ul><h2 id="怎样-记住-信息-而不触发重新渲染" tabindex="-1"><a class="header-anchor" href="#怎样-记住-信息-而不触发重新渲染"><span>怎样“记住”信息，而不触发重新渲染？</span></a></h2><ul><li>可以使用 <code>ref</code>，它会记住信息，ref 的变更也不会触发新的渲染。</li><li>ref 和 state 的区别 <table><thead><tr><th>ref</th><th>state</th></tr></thead><tbody><tr><td><a href="https://zh-hans.react.dev/reference/react/useRef#reference" target="_blank" rel="noopener noreferrer">useRef</a></td><td><a href="https://zh-hans.react.dev/reference/react/useState#reference" target="_blank" rel="noopener noreferrer"><code>useState</code></a></td></tr><tr><td>修改时不触发渲染</td><td>修改时触发渲染</td></tr><tr><td>可变，可以在渲染过程之外修改 current 的值</td><td>“不可变”，你必须使用 state setter 函数修改 state，从而排队重新渲染</td></tr><tr><td>不应在渲染期间读取、写入 current</td><td>可以随时读取 state，但每次渲染都有自己不变的 state 快照</td></tr></tbody></table></li><li>何时使用 <a href="https://zh-hans.react.dev/reference/react/useRef#reference" target="_blank" rel="noopener noreferrer">useRef</a>？ <ul><li>当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener noreferrer">timeout ID</a></li><li>存储和操作 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element" target="_blank" rel="noopener noreferrer">DOM 元素</a></li><li>存储不需要被用来计算 JSX 的其他对象</li></ul></li><li>ref 的最佳实践 <ul><li><code>将 ref 视为脱围机制</code>：当使用外部系统或浏览器 API 时，如果应用程序逻辑和数据流很大一部分依赖于 ref，你可能需要重新考虑你的设计。</li><li><code>不要在渲染过程中读取或写入 ref.current</code>：通常渲染过程中需要某些信息，应该使用 state，而不是 ref。</li></ul></li></ul><h3 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h3><ul><li>ref 是一种脱围机制，用于保留不用于渲染的值。 你不会经常需要它们。</li><li>ref 是一个普通的 JavaScript 对象，具有一个名为 current 的属性，你可以对其进行读取或设置。</li><li>你可以通过调用 useRef Hook 来让 React 给你一个 ref。</li><li>与 state 一样，ref 允许你在组件的重新渲染之间保留信息。</li><li>与 state 不同，设置 ref 的 current 值不会触发重新渲染。</li><li>不要在渲染过程中读取或写入 ref.current。这使你的组件难以预测。</li></ul><h3 id="尝试一些挑战" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/referencing-values-with-refs#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>修复坏掉的聊天输入框</li><li>修复无法重新渲染的组件</li><li>修复防抖</li><li>读取最新的 state</li></ul></li></ul><h2 id="在-react-中怎样访问-dom" tabindex="-1"><a class="header-anchor" href="#在-react-中怎样访问-dom"><span>在 React 中怎样访问 DOM？</span></a></h2><ul><li>使用一个指向 DOM 节点的 ref 就可以访问 DOM，实现 DOM 节点获得焦点、滚动或测量它的尺寸和位置。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">useRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;react&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 最初 myRef.current 是 null</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> myRef</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> ref</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">myRef</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">// 现在 可以使用浏览器 API 访问 DOM 节点</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">myRef.current.scrollIntoView();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>怎样在循环中使用 ref？<a href="https://zh-hans.react.dev/reference/react-dom/components/common#ref-callback" target="_blank" rel="noopener noreferrer">ref 回调函数</a></li><li>如何访问另一个组件的 DOM 节点？ <ul><li>使用 <a href="https://zh-hans.react.dev/reference/react/forwardRef#reference" target="_blank" rel="noopener noreferrer">forwardRef</a> 让组件接收 ref 并将其传递给子组件</li></ul></li><li>React 何时添加 refs？ <ul><li>React 在提交阶段设置 ref.current</li><li>更新 DOM 之前，React 将受影响的 ref.current 设置为 null，DOM 更新后，立即设置 ref.current</li></ul></li><li><a href="https://zh-hans.react.dev/learn/queueing-a-series-of-state-updates" target="_blank" rel="noopener noreferrer">state 更新是排队进行的</a>：所以在修改 state 后，操作 ref 会出现落后的问题，怎么解决？ <ul><li><a href="https://zh-hans.react.dev/reference/react-dom/flushSync#reference" target="_blank" rel="noopener noreferrer">flushSync(callback)</a>，你应将其作为最后手段使用</li><li>示例：<a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync" target="_blank" rel="noopener noreferrer">用 flushSync 同步更新 state</a></li></ul></li><li>使用 refs 操作 DOM 的最佳实践 <ul><li>ref 是一种 React 的例外机制，应该在只有跳出 React 时使用，如：管理焦点、滚动位置，或调用 React 未暴露的浏览器 API 时使用。</li><li>如果你通过 ref 手动修改 DOM 可能会与 React 所做的更改发生冲突。</li><li>React 应用更改到 DOM，所以你可以通过 ref 修改 React 永远不会更改的部分就可以避免冲突。</li></ul></li></ul><h3 id="摘要-1" tabindex="-1"><a class="header-anchor" href="#摘要-1"><span>摘要</span></a></h3><ul><li>Refs 是一个通用概念，但大多数情况下你会使用它们来保存 DOM 元素。</li><li>你通过传递 <code>&lt;div ref={myRef}&gt;</code> 指示 React 将 DOM 节点放入 myRef.current。</li><li>通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。</li><li>默认情况下，组件不暴露其 DOM 节点。 你可以通过使用 forwardRef 并将第二个 ref 参数传递给特定节点来暴露 DOM 节点。</li><li>避免更改由 React 管理的 DOM 节点。</li><li>如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。</li></ul><h3 id="尝试一些挑战-1" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-1"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li>播放和暂停视频</li><li>使搜索域获得焦点</li><li>滚动图像轮播</li><li>使分开的组件中的搜索域获得焦点</li></ul></li></ul><h2 id="怎样将组件与外部系统同步" tabindex="-1"><a class="header-anchor" href="#怎样将组件与外部系统同步"><span>怎样将组件与外部系统同步？</span></a></h2><ul><li>使用 Effect 进行同步</li></ul><h2 id="从组件中删除不必要的-effect" tabindex="-1"><a class="header-anchor" href="#从组件中删除不必要的-effect"><span>从组件中删除不必要的 Effect</span></a></h2><ul><li>两种常见的不必使用 Effect 的情况： <ul><li>不要为了渲染而使用 Effect 来转换数据。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">fullName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setFullName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  setFullName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">firstName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39; &#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> lastName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">firstName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">lastName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 这是没必要的，应该 fullName 是可计算的，更好的实现如下：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> fullName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> firstName</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39; &#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> lastName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>不要使用 Effect 来处理用户事件。</li></ul></li></ul><h2 id="effect-的生命周期-不同于-组件的生命周期" tabindex="-1"><a class="header-anchor" href="#effect-的生命周期-不同于-组件的生命周期"><span>Effect 的生命周期 不同于 组件的生命周期?</span></a></h2><ul><li>组件可以挂载、更新、卸载，但是 Effect 只能做两件事：<code>开始同步某些东西</code> 和 <code>停止同步它</code>。</li><li>Effect 如果依赖于随时间变化的 props 和 state，这个循环会发生多次。</li></ul><h2 id="防止某些值重新触发-effect" tabindex="-1"><a class="header-anchor" href="#防止某些值重新触发-effect"><span>防止某些值重新触发 Effect</span></a></h2><h2 id="减少-effect-重新执行的频率" tabindex="-1"><a class="header-anchor" href="#减少-effect-重新执行的频率"><span>减少 Effect 重新执行的频率</span></a></h2><h2 id="在组件之间共享逻辑" tabindex="-1"><a class="header-anchor" href="#在组件之间共享逻辑"><span>在组件之间共享逻辑</span></a></h2>`,23)]))}const c=t(l,[["render",r],["__file","react-learn-04-escape.html.vue"]]),d=JSON.parse('{"path":"/code/fe/react/react-learn-04-escape.html","title":"React 脱围机制（Escape Hatches）","lang":"zh-CN","frontmatter":{"title":"React 脱围机制（Escape Hatches）","shortTitle":"React 脱围机制","icon":"magnet","date":"2024-12-06T14:46:36.000Z","category":["前端","react"],"tag":["react","escape"],"order":17,"description":"参考 React 官方文档 demo 怎样“记住”信息，而不触发重新渲染？ 可以使用 ref，它会记住信息，ref 的变更也不会触发新的渲染。 ref 和 state 的区别 何时使用 useRef？ 当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 timeout ID 存储和操作 DOM 元素 存储不需要被用来计算 JS...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/react/react-learn-04-escape.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"React 脱围机制（Escape Hatches）"}],["meta",{"property":"og:description","content":"参考 React 官方文档 demo 怎样“记住”信息，而不触发重新渲染？ 可以使用 ref，它会记住信息，ref 的变更也不会触发新的渲染。 ref 和 state 的区别 何时使用 useRef？ 当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 timeout ID 存储和操作 DOM 元素 存储不需要被用来计算 JS..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-09T03:05:19.000Z"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"escape"}],["meta",{"property":"article:published_time","content":"2024-12-06T14:46:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-09T03:05:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 脱围机制（Escape Hatches）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-06T14:46:36.000Z\\",\\"dateModified\\":\\"2024-12-09T03:05:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]},{"level":2,"title":"怎样“记住”信息，而不触发重新渲染？","slug":"怎样-记住-信息-而不触发重新渲染","link":"#怎样-记住-信息-而不触发重新渲染","children":[{"level":3,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战","link":"#尝试一些挑战","children":[]}]},{"level":2,"title":"在 React 中怎样访问 DOM？","slug":"在-react-中怎样访问-dom","link":"#在-react-中怎样访问-dom","children":[{"level":3,"title":"摘要","slug":"摘要-1","link":"#摘要-1","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-1","link":"#尝试一些挑战-1","children":[]}]},{"level":2,"title":"怎样将组件与外部系统同步？","slug":"怎样将组件与外部系统同步","link":"#怎样将组件与外部系统同步","children":[]},{"level":2,"title":"从组件中删除不必要的 Effect","slug":"从组件中删除不必要的-effect","link":"#从组件中删除不必要的-effect","children":[]},{"level":2,"title":"Effect 的生命周期 不同于 组件的生命周期?","slug":"effect-的生命周期-不同于-组件的生命周期","link":"#effect-的生命周期-不同于-组件的生命周期","children":[]},{"level":2,"title":"防止某些值重新触发 Effect","slug":"防止某些值重新触发-effect","link":"#防止某些值重新触发-effect","children":[]},{"level":2,"title":"减少 Effect 重新执行的频率","slug":"减少-effect-重新执行的频率","link":"#减少-effect-重新执行的频率","children":[]},{"level":2,"title":"在组件之间共享逻辑","slug":"在组件之间共享逻辑","link":"#在组件之间共享逻辑","children":[]}],"git":{"createdTime":1733645746000,"updatedTime":1733713519000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":2}]},"readingTime":{"minutes":4.5,"words":1351},"filePathRelative":"code/fe/react/react-learn-04-escape.md","localizedDate":"2024年12月6日","excerpt":"<h2>参考</h2>\\n<ul>\\n<li><a href=\\"https://zh-hans.react.dev/learn/escape-hatches\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">React 官方文档</a></li>\\n<li><a href=\\"https://www.takeseem.com/demo-react/demo/react-escape\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">demo</a></li>\\n</ul>\\n<h2>怎样“记住”信息，而不触发重新渲染？</h2>\\n<ul>\\n<li>可以使用 <code>ref</code>，它会记住信息，ref 的变更也不会触发新的渲染。</li>\\n<li>ref 和 state 的区别\\n<table>\\n<thead>\\n<tr>\\n<th>ref</th>\\n<th>state</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><a href=\\"https://zh-hans.react.dev/reference/react/useRef#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">useRef</a></td>\\n<td><a href=\\"https://zh-hans.react.dev/reference/react/useState#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>useState</code></a></td>\\n</tr>\\n<tr>\\n<td>修改时不触发渲染</td>\\n<td>修改时触发渲染</td>\\n</tr>\\n<tr>\\n<td>可变，可以在渲染过程之外修改 current 的值</td>\\n<td>“不可变”，你必须使用 state setter 函数修改 state，从而排队重新渲染</td>\\n</tr>\\n<tr>\\n<td>不应在渲染期间读取、写入 current</td>\\n<td>可以随时读取 state，但每次渲染都有自己不变的 state 快照</td>\\n</tr>\\n</tbody>\\n</table>\\n</li>\\n<li>何时使用 <a href=\\"https://zh-hans.react.dev/reference/react/useRef#reference\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">useRef</a>？\\n<ul>\\n<li>当组件需要跳出 React 与外部 API 交互时就会用到 ref，如：存储 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">timeout ID</a></li>\\n<li>存储和操作 <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">DOM 元素</a></li>\\n<li>存储不需要被用来计算 JSX 的其他对象</li>\\n</ul>\\n</li>\\n<li>ref 的最佳实践\\n<ul>\\n<li><code>将 ref 视为脱围机制</code>：当使用外部系统或浏览器 API 时，如果应用程序逻辑和数据流很大一部分依赖于 ref，你可能需要重新考虑你的设计。</li>\\n<li><code>不要在渲染过程中读取或写入 ref.current</code>：通常渲染过程中需要某些信息，应该使用 state，而不是 ref。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,d as data};
