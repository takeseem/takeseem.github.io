import{_ as s,c as e,a,o as t}from"./app-DTtaFhv3.js";const l="/assets/react-learn-03-state-1-o4Sg5sdt.png",n={};function h(r,i){return t(),e("div",null,i[0]||(i[0]=[a('<h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://zh-hans.react.dev/learn/managing-state" target="_blank" rel="noopener noreferrer">React 官方文档</a></li><li><a href="https://www.takeseem.com/demo-react/demo/react-state" target="_blank" rel="noopener noreferrer">demo</a></li></ul><h2 id="将-ui-视为-state" tabindex="-1"><a class="header-anchor" href="#将-ui-视为-state"><span>将 UI 视为 state</span></a></h2><h3 id="声明式-ui-编程与命令式-ui-编程有何不同" tabindex="-1"><a class="header-anchor" href="#声明式-ui-编程与命令式-ui-编程有何不同"><span>声明式 UI 编程与命令式 UI 编程有何不同？</span></a></h3><ul><li>命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 <ul><li>他不知道你想要去哪儿，所以他只能根据你的指令来行动。</li><li>你必须知道执行的每个细节和步骤，并处理每个可能的错误。</li></ul></li><li>声明式编程：你告诉他要去哪儿，然后他去了。 <ul><li>你只需告诉他要去哪儿，而不是事无巨细的告诉他如何走，他就会将你带到目的地。</li><li>你只需声明你想要的，React 会计算出如何去更新 UI。</li></ul></li></ul><h3 id="怎样声明式地考虑-ui" tabindex="-1"><a class="header-anchor" href="#怎样声明式地考虑-ui"><span>怎样声明式地考虑 UI？</span></a></h3><ol><li><code>定位</code>你的组件中不同的视图状态</li></ol><ul><li>如表单：未填写、输入中、提交中、成功时、错误时。</li></ul><ol start="2"><li><code>确定</code>是什么触发了这些 <code>state</code> 的改变</li></ol><ul><li>人为输入：点击、填写内容、点击导航链接等，通常需要：<a href="https://zh-hans.react.dev/learn/responding-to-events" target="_blank" rel="noopener noreferrer">事件处理函数</a></li><li>计算机输入：网络请求反馈、定时器、加载图片等。</li><li>如：表单的各种状态： <img src="'+l+`" alt="表单的各种状态" loading="lazy"></li></ul><ol start="3"><li><code>表示</code>内存中的 state（需要使用 <code>useState</code>）</li><li><code>删除</code>任何不必要的 state 变量</li></ol><ul><li>怎样找出不必要的 state 变量？问问自己： <ul><li><code>这个 state 是否会导致矛盾？</code>例如，isTyping 与 isSubmitting 的状态不能同时为 true。矛盾的产生通常说明了这个 state 没有足够的约束条件。两个布尔值有四种可能的组合，但是只有三种对应有效的状态。为了将“不可能”的状态移除，你可以将他们合并到一个 &#39;status&#39; 中，它的值必须是 &#39;typing&#39;、&#39;submitting&#39; 以及 &#39;success&#39; 这三个中的一个。</li><li><code>相同的信息是否已经在另一个 state 变量中存在？</code>另一个矛盾：isEmpty 和 isTyping 不能同时为 true。通过使它们成为独立的 state 变量，可能会导致它们不同步并导致 bug。幸运的是，你可以移除 isEmpty 转而用 message.length === 0。</li><li><code>你是否可以通过另一个 state 变量的相反值得到相同的信息？</code>isError 是多余的，因为你可以检查 error !== null。</li></ul></li><li>通过 <a href="https://zh-hans.react.dev/learn/extracting-state-logic-into-a-reducer" target="_blank" rel="noopener noreferrer">将状态提取到一个 reducer 中</a> 减少“不可能” state</li></ul><ol start="5"><li><code>连接</code>事件处理函数去设置 state</li></ol><h3 id="尝试一些挑战" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/reacting-to-input-with-state#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a>：务必 Fork 再修复以避免内嵌导致的一些莫名其妙错误。 <ul><li><code>添加和删除一个 CSS class</code> 收获：useState 的使用，事件冒泡。</li><li><code>个人信息编辑器</code> 收获：React 很简单，form submit 默认行为处理。</li><li><code>不使用 React 去重构命令式的解决方案</code> 收获：怎样用 JS 直接操作 DOM，深刻体会 React 的优势。</li></ul></li></ul><h2 id="如何组织好-state-状态结构" tabindex="-1"><a class="header-anchor" href="#如何组织好-state-状态结构"><span>如何组织好 state 状态结构？</span></a></h2><h3 id="state-构建原则" tabindex="-1"><a class="header-anchor" href="#state-构建原则"><span>state 构建原则</span></a></h3><ol><li><code>合并关联的 state</code>：如果总是同时更新两个或更多 state，考虑将它们合为一个单独的 state 变量。</li><li><code>避免矛盾的 state</code>：应尽量避免 state 结构中存在多个相互矛盾或“不一致”的 state。</li><li><code>避免冗余的 state</code>：如果能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入 state 中。</li><li><code>避免重复的 state</code>：当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，很难保持它们同步。应尽可能减少重复。</li><li><code>避免深度嵌套的 state</code>：深度分层的 state 更新起来不方便，最好以扁平化方式构建 state。有时候可以将一些嵌套 state 移动到子组件中来减少 state 的嵌套，通常是不需要保持的短暂 UI 状态，如：一个选项是否被悬停。</li></ol><h3 id="摘要" tabindex="-1"><a class="header-anchor" href="#摘要"><span>摘要</span></a></h3><ul><li>如果两个 state 变量总是一起更新，请考虑将它们合并为一个。</li><li>仔细选择你的 state 变量，以避免创建“极难处理”的 state。</li><li>用一种减少出错更新的机会的方式来构建你的 state。</li><li>避免冗余和重复的 state，这样你就不需要保持同步。</li><li>除非你特别想防止更新，否则不要将 props 放入 state 中。</li><li>对于选择类型的 UI 模式，请在 state 中保存 ID 或索引而不是对象本身。</li><li>如果深度嵌套 state 更新很复杂，请尝试将其展开扁平化。</li></ul><h3 id="尝试一些挑战-1" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-1"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/choosing-the-state-structure#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a> 务必 Fork 再修复以避免内嵌导致的一些莫名其妙错误。 <ul><li>修复一个未更新的组件：因为定义了非必要的 state。</li><li>修复一个损坏的打包清单：total 和 packed 是可计算的，无须定义 state。<div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setItems</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">initialItems</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> total</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> packed</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">items</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forEach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">v</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">packed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">packed</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>修复消失的选项 <ul><li>因为比较的是对象：<code>isHighlighted={letter === highlightedLetter}</code>，而点击后是一个新对象，肯定不相等</li><li>修复：应比较对象的标识：<code>isHighlighted={letter.id === highlightedLetter?.id}</code>，注意首次高亮对象是 null</li></ul></li><li>实现多选功能：如果熟悉 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">Array API</a> 很快就能实现 <ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">findIndex</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced" target="_blank" rel="noopener noreferrer">toSpliced</a></li></ul><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" data-title="jsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setSelectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([]);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> selectedCount</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> handleToggle</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> idx</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">findIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> v</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  setSelectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    idx</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      ?</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toSpliced</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">toggledId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">      :</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> selectedIds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toSpliced</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">idx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="如何使用-状态提升-在组件之间共享状态" tabindex="-1"><a class="header-anchor" href="#如何使用-状态提升-在组件之间共享状态"><span>如何使用“状态提升”在组件之间共享状态</span></a></h2><ul><li>把 state 放到它们的公共父级——这被称为“状态提升”</li><li>如何使用状态提升在组件之间共享状态</li><li>什么是受控组件和非受控组件 <ul><li><code>非受控组件</code>：组件由其自身内部状态控制的叫非受控组件。</li><li><code>受控组件</code>：组件由 <code>props</code> 输入控制的就叫受控组件。</li></ul></li></ul><h3 id="尝试一些挑战-2" tabindex="-1"><a class="header-anchor" href="#尝试一些挑战-2"><span>尝试一些挑战</span></a></h3><ul><li>务必完成官方：<a href="https://zh-hans.react.dev/learn/sharing-state-between-components#challenges" target="_blank" rel="noopener noreferrer">尝试一些挑战</a><ul><li><a href="">挑战: 同步输入状态</a></li><li><a href="">挑战: 列表过滤</a></li></ul></li></ul><h2 id="如何控制状态的保留或重置" tabindex="-1"><a class="header-anchor" href="#如何控制状态的保留或重置"><span>如何控制状态的保留或重置</span></a></h2><h2 id="如何在函数中整合复杂的状态逻辑" tabindex="-1"><a class="header-anchor" href="#如何在函数中整合复杂的状态逻辑"><span>如何在函数中整合复杂的状态逻辑</span></a></h2><h2 id="如何避免数据通过-prop-逐级透传" tabindex="-1"><a class="header-anchor" href="#如何避免数据通过-prop-逐级透传"><span>如何避免数据通过 prop 逐级透传</span></a></h2><h2 id="如何随着应用的增长去扩展状态管理" tabindex="-1"><a class="header-anchor" href="#如何随着应用的增长去扩展状态管理"><span>如何随着应用的增长去扩展状态管理</span></a></h2>`,30)]))}const k=s(n,[["render",h],["__file","react-learn-03-state.html.vue"]]),d=JSON.parse('{"path":"/code/fe/react/react-learn-03-state.html","title":"React 状态管理","lang":"zh-CN","frontmatter":{"title":"React 状态管理","icon":"store","date":"2024-12-03T14:22:36.000Z","category":["前端","react"],"tag":["react","state"],"order":17,"description":"参考 React 官方文档 demo 将 UI 视为 state 声明式 UI 编程与命令式 UI 编程有何不同？ 命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 他不知道你想要去哪儿，所以他只能根据你的指令来行动。 你必须知道执行的每个细节和步骤，并处理每个可能的错误。 声明式编程：你告诉他要去哪儿，然后他去了。 你只需告诉他要去哪儿，而不是事...","head":[["meta",{"property":"og:url","content":"https://www.takeseem.com/code/fe/react/react-learn-03-state.html"}],["meta",{"property":"og:site_name","content":"全球指数"}],["meta",{"property":"og:title","content":"React 状态管理"}],["meta",{"property":"og:description","content":"参考 React 官方文档 demo 将 UI 视为 state 声明式 UI 编程与命令式 UI 编程有何不同？ 命令式编程：你坐在车上然后一步一步的告诉他该去哪儿。 他不知道你想要去哪儿，所以他只能根据你的指令来行动。 你必须知道执行的每个细节和步骤，并处理每个可能的错误。 声明式编程：你告诉他要去哪儿，然后他去了。 你只需告诉他要去哪儿，而不是事..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-04T13:13:33.000Z"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"state"}],["meta",{"property":"article:published_time","content":"2024-12-03T14:22:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-04T13:13:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 状态管理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-03T14:22:36.000Z\\",\\"dateModified\\":\\"2024-12-04T13:13:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"全球指数\\",\\"url\\":\\"https://www.takeseem.com\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]},{"level":2,"title":"将 UI 视为 state","slug":"将-ui-视为-state","link":"#将-ui-视为-state","children":[{"level":3,"title":"声明式 UI 编程与命令式 UI 编程有何不同？","slug":"声明式-ui-编程与命令式-ui-编程有何不同","link":"#声明式-ui-编程与命令式-ui-编程有何不同","children":[]},{"level":3,"title":"怎样声明式地考虑 UI？","slug":"怎样声明式地考虑-ui","link":"#怎样声明式地考虑-ui","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战","link":"#尝试一些挑战","children":[]}]},{"level":2,"title":"如何组织好 state 状态结构？","slug":"如何组织好-state-状态结构","link":"#如何组织好-state-状态结构","children":[{"level":3,"title":"state 构建原则","slug":"state-构建原则","link":"#state-构建原则","children":[]},{"level":3,"title":"摘要","slug":"摘要","link":"#摘要","children":[]},{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-1","link":"#尝试一些挑战-1","children":[]}]},{"level":2,"title":"如何使用“状态提升”在组件之间共享状态","slug":"如何使用-状态提升-在组件之间共享状态","link":"#如何使用-状态提升-在组件之间共享状态","children":[{"level":3,"title":"尝试一些挑战","slug":"尝试一些挑战-2","link":"#尝试一些挑战-2","children":[]}]},{"level":2,"title":"如何控制状态的保留或重置","slug":"如何控制状态的保留或重置","link":"#如何控制状态的保留或重置","children":[]},{"level":2,"title":"如何在函数中整合复杂的状态逻辑","slug":"如何在函数中整合复杂的状态逻辑","link":"#如何在函数中整合复杂的状态逻辑","children":[]},{"level":2,"title":"如何避免数据通过 prop 逐级透传","slug":"如何避免数据通过-prop-逐级透传","link":"#如何避免数据通过-prop-逐级透传","children":[]},{"level":2,"title":"如何随着应用的增长去扩展状态管理","slug":"如何随着应用的增长去扩展状态管理","link":"#如何随着应用的增长去扩展状态管理","children":[]}],"git":{"createdTime":1733318013000,"updatedTime":1733318013000,"contributors":[{"name":"takeseem","email":"takeseem@gmail.com","commits":1}]},"readingTime":{"minutes":5.36,"words":1609},"filePathRelative":"code/fe/react/react-learn-03-state.md","localizedDate":"2024年12月3日","excerpt":"<h2>参考</h2>\\n<ul>\\n<li><a href=\\"https://zh-hans.react.dev/learn/managing-state\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">React 官方文档</a></li>\\n<li><a href=\\"https://www.takeseem.com/demo-react/demo/react-state\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">demo</a></li>\\n</ul>\\n<h2>将 UI 视为 state</h2>\\n<h3>声明式 UI 编程与命令式 UI 编程有何不同？</h3>","autoDesc":true}');export{k as comp,d as data};
